//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// SPDX-FileCopyrightText: 2024 Seal, Inc
// SPDX-License-Identifier: Apache-2.0

// Code generated by "walrus". DO NOT EDIT.
package crd_gen

import (
	v1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	ptr "k8s.io/utils/ptr"
)

func GetCustomResourceDefinitions() map[string]*v1.CustomResourceDefinition {
	return map[string]*v1.CustomResourceDefinition{
		"Dummy": crd_crd_gen_generators_testdata_crd_gen_Dummy(),
	}
}

func crd_crd_gen_generators_testdata_crd_gen_Dummy() *v1.CustomResourceDefinition {
	return &v1.CustomResourceDefinition{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "apiextensions.k8s.io/v1",
			Kind:       "CustomResourceDefinition",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: "dummies.samplecontroller.k8s.io",
		},
		Spec: v1.CustomResourceDefinitionSpec{
			Group: "samplecontroller.k8s.io",
			Names: v1.CustomResourceDefinitionNames{
				Plural:   "projects",
				Singular: "dummy",
				ShortNames: []string{
					"proj",
				},
				Kind:     "Dummy",
				ListKind: "DummyList",
				Categories: []string{
					"all",
					"walrus",
				},
			},
			Scope: "Namespaced",
			Versions: []v1.CustomResourceDefinitionVersion{
				{
					Name:    "v1",
					Served:  true,
					Storage: true,
					Schema: &v1.CustomResourceValidation{
						OpenAPIV3Schema: &v1.JSONSchemaProps{
							Description: "Dummy is the schema for the projects API.",
							Type:        "object",
							Required: []string{
								"metadata",
								"spec",
							},
							Properties: map[string]v1.JSONSchemaProps{
								"apiVersion": {
									Type: "string",
								},
								"kind": {
									Type: "string",
								},
								"metadata": {
									Type: "object",
								},
								"spec": {
									Type: "object",
									Required: []string{
										"integerPointer",
										"floatPointer",
										"stringPointer",
										"boolPointer",
										"microTime",
										"duration",
										"time",
										"intOrString",
										"rawExtension",
										"microTimePointer",
										"durationPointer",
										"timePointer",
										"intOrStringPointer",
										"rawExtensionPointer",
										"mapString",
										"mapPointString",
										"mapObject",
										"mapInOrString",
										"mapStringPointer",
										"mapInterface",
										"sliceString",
										"slicePointString",
										"sliceObject",
										"sliceBytes",
										"sliceBytesPointer",
										"sliceInterface",
										"arrayString",
										"arrayPointString",
										"arrayObject",
										"subDummySpecPointer",
										"sliceSubDummySpec",
										"dummyX",
										"dummyY",
										"quantity",
									},
									Properties: map[string]v1.JSONSchemaProps{
										"arrayObject": {
											Type:     "object",
											MaxItems: ptr.To[int64](3),
											MinItems: ptr.To[int64](3),
											Required: []string{
												"a",
												"b",
												"c",
												"d",
												"e",
											},
											Properties: map[string]v1.JSONSchemaProps{
												"a": {
													Type: "string",
												},
												"b": {
													Type: "integer",
												},
												"c": {
													Type: "boolean",
												},
												"d": {
													Type:   "number",
													Format: "double",
												},
												"e": {
													Type: "object",
													AdditionalProperties: &v1.JSONSchemaPropsOrBool{
														Allows: true,
														Schema: &v1.JSONSchemaProps{
															Type: "object",
														},
													},
													Nullable: true,
												},
											},
											XValidations: []v1.ValidationRule{
												{
													Rule:    "self.b > 0",
													Message: "b must be greater than 0,",
												},
												{
													Rule:    "self.e.length() % 2 == 0\n? self.a == self.a + ' is even'\n: self.a == self.a + ' is odd'",
													Message: "mutate a",
													Reason:  ptr.To[v1.FieldValueErrorReason]("FieldValueRequired"),
												},
											},
										},
										"arrayPointString": {
											Type:     "string",
											MaxItems: ptr.To[int64](3),
											MinItems: ptr.To[int64](3),
											Nullable: true,
										},
										"arrayString": {
											Type:     "string",
											MaxItems: ptr.To[int64](3),
											MinItems: ptr.To[int64](3),
										},
										"bool": {
											Type: "boolean",
										},
										"boolPointer": {
											Type:     "boolean",
											Nullable: true,
										},
										"dummyX": {
											Type: "object",
											Required: []string{
												"z",
												"x",
											},
											Properties: map[string]v1.JSONSchemaProps{
												"x": {
													Type:                   "object",
													Nullable:               true,
													XPreserveUnknownFields: ptr.To[bool](true),
												},
												"z": {
													Type: "object",
													Required: []string{
														"test",
													},
													Properties: map[string]v1.JSONSchemaProps{
														"test": {
															Type: "string",
														},
													},
												},
											},
										},
										"dummyY": {
											Type: "object",
											Required: []string{
												"z",
												"y",
											},
											Properties: map[string]v1.JSONSchemaProps{
												"y": {
													Type:                   "object",
													Nullable:               true,
													XPreserveUnknownFields: ptr.To[bool](true),
												},
												"z": {
													Type: "object",
													Required: []string{
														"test",
													},
													Properties: map[string]v1.JSONSchemaProps{
														"test": {
															Type: "string",
														},
													},
												},
											},
										},
										"duration": {
											Type:   "string",
											Format: "duration",
										},
										"durationPointer": {
											Type:     "string",
											Format:   "duration",
											Nullable: true,
										},
										"float": {
											Type:   "number",
											Format: "double",
										},
										"floatPointer": {
											Type:     "number",
											Format:   "float",
											Maximum:  ptr.To[float64](10),
											Nullable: true,
										},
										"intOrString": {
											AnyOf: []v1.JSONSchemaProps{
												{
													Type: "integer",
												},
												{
													Type: "string",
												},
											},
											XIntOrString: true,
										},
										"intOrStringPointer": {
											AnyOf: []v1.JSONSchemaProps{
												{
													Type: "integer",
												},
												{
													Type: "string",
												},
											},
											Nullable:     true,
											XIntOrString: true,
										},
										"integer": {
											Type:    "integer",
											Minimum: ptr.To[float64](1),
										},
										"integerPointer": {
											Type:   "integer",
											Format: "int64",
											Enum: []v1.JSON{
												{
													Raw: []byte(`1`),
												},
												{
													Raw: []byte(`2`),
												},
												{
													Raw: []byte(`3`),
												},
												{
													Raw: []byte(`5`),
												},
												{
													Raw: []byte(`7`),
												},
											},
										},
										"mapInOrString": {
											Type: "object",
											AdditionalProperties: &v1.JSONSchemaPropsOrBool{
												Allows: true,
												Schema: &v1.JSONSchemaProps{
													AnyOf: []v1.JSONSchemaProps{
														{
															Type: "integer",
														},
														{
															Type: "string",
														},
													},
													XIntOrString: true,
												},
											},
											Nullable: true,
											XMapType: ptr.To[string]("atomic"),
										},
										"mapInterface": {
											Type: "object",
											AdditionalProperties: &v1.JSONSchemaPropsOrBool{
												Allows: true,
												Schema: &v1.JSONSchemaProps{
													Type:                   "object",
													XPreserveUnknownFields: ptr.To[bool](true),
												},
											},
											Nullable: true,
										},
										"mapObject": {
											Type: "object",
											AdditionalProperties: &v1.JSONSchemaPropsOrBool{
												Allows: true,
												Schema: &v1.JSONSchemaProps{
													Type: "object",
													Required: []string{
														"a",
														"b",
														"c",
														"d",
														"e",
														"f",
													},
													Properties: map[string]v1.JSONSchemaProps{
														"a": {
															Type: "string",
														},
														"b": {
															Type: "integer",
														},
														"c": {
															Type: "boolean",
														},
														"d": {
															Type:   "number",
															Format: "double",
														},
														"e": {
															Type: "object",
															AdditionalProperties: &v1.JSONSchemaPropsOrBool{
																Allows: true,
																Schema: &v1.JSONSchemaProps{
																	Type: "object",
																},
															},
															Nullable: true,
														},
														"f": {
															Type: "array",
															Items: &v1.JSONSchemaPropsOrArray{
																Schema: &v1.JSONSchemaProps{
																	Type: "object",
																},
															},
															Nullable: true,
														},
													},
												},
											},
											Nullable: true,
										},
										"mapPointString": {
											Type: "object",
											AdditionalProperties: &v1.JSONSchemaPropsOrBool{
												Allows: true,
												Schema: &v1.JSONSchemaProps{
													Type:     "string",
													Nullable: true,
												},
											},
											Nullable: true,
										},
										"mapString": {
											Type:          "object",
											MaxProperties: ptr.To[int64](3),
											AdditionalProperties: &v1.JSONSchemaPropsOrBool{
												Allows: true,
												Schema: &v1.JSONSchemaProps{
													Type: "string",
												},
											},
											Nullable: true,
											XMapType: ptr.To[string]("atomic"),
										},
										"mapStringPointer": {
											Type: "object",
											AdditionalProperties: &v1.JSONSchemaPropsOrBool{
												Allows: true,
												Schema: &v1.JSONSchemaProps{
													Type: "string",
												},
											},
											Nullable: true,
										},
										"microTime": {
											Type:   "string",
											Format: "date-time",
										},
										"microTimePointer": {
											Type:     "string",
											Format:   "date-time",
											Nullable: true,
										},
										"quantity": {
											Pattern: `^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$`,
											AnyOf: []v1.JSONSchemaProps{
												{
													Type: "integer",
												},
												{
													Type: "string",
												},
											},
											XIntOrString: true,
										},
										"rawExtension": {
											Type:                   "object",
											XPreserveUnknownFields: ptr.To[bool](true),
										},
										"rawExtensionPointer": {
											Type:                   "object",
											Nullable:               true,
											XPreserveUnknownFields: ptr.To[bool](true),
										},
										"sliceBytes": {
											Type:     "string",
											Format:   "byte",
											Nullable: true,
										},
										"sliceBytesPointer": {
											Type:     "string",
											Format:   "byte",
											Nullable: true,
										},
										"sliceInterface": {
											Type: "array",
											Items: &v1.JSONSchemaPropsOrArray{
												Schema: &v1.JSONSchemaProps{
													Type:                   "object",
													XPreserveUnknownFields: ptr.To[bool](true),
												},
											},
											Nullable: true,
										},
										"sliceObject": {
											Type: "array",
											Items: &v1.JSONSchemaPropsOrArray{
												Schema: &v1.JSONSchemaProps{
													Type: "object",
													Required: []string{
														"a",
														"b",
														"c",
														"d",
														"e",
														"f",
													},
													Properties: map[string]v1.JSONSchemaProps{
														"a": {
															Type: "string",
														},
														"b": {
															Type: "integer",
														},
														"c": {
															Type: "boolean",
														},
														"d": {
															Type:   "number",
															Format: "double",
														},
														"e": {
															Type: "object",
															AdditionalProperties: &v1.JSONSchemaPropsOrBool{
																Allows: true,
																Schema: &v1.JSONSchemaProps{
																	Type: "object",
																},
															},
															Nullable: true,
														},
														"f": {
															Type: "array",
															Items: &v1.JSONSchemaPropsOrArray{
																Schema: &v1.JSONSchemaProps{
																	Type: "object",
																},
															},
															Nullable: true,
														},
													},
												},
											},
											Nullable: true,
											XValidations: []v1.ValidationRule{
												{
													Rule:    "self.b > 0",
													Message: "b must be greater than 0",
												},
											},
										},
										"slicePointString": {
											Type: "array",
											Items: &v1.JSONSchemaPropsOrArray{
												Schema: &v1.JSONSchemaProps{
													Type:     "string",
													Nullable: true,
												},
											},
											Nullable: true,
										},
										"sliceString": {
											Type:     "array",
											MaxItems: ptr.To[int64](3),
											MinItems: ptr.To[int64](1),
											Items: &v1.JSONSchemaPropsOrArray{
												Schema: &v1.JSONSchemaProps{
													Type: "string",
												},
											},
											Nullable: true,
										},
										"sliceSubDummySpec": {
											Type: "array",
											Items: &v1.JSONSchemaPropsOrArray{
												Schema: &v1.JSONSchemaProps{
													Type:                   "object",
													XPreserveUnknownFields: ptr.To[bool](true),
												},
											},
											Nullable: true,
										},
										"string": {
											Type: "string",
											Enum: []v1.JSON{
												{
													Raw: []byte(`"x"`),
												},
												{
													Raw: []byte(`"y"`),
												},
												{
													Raw: []byte(`"z"`),
												},
											},
										},
										"stringPointer": {
											Type:     "string",
											Nullable: true,
										},
										"subDummySpecPointer": {
											Type:                   "object",
											Nullable:               true,
											XPreserveUnknownFields: ptr.To[bool](true),
										},
										"time": {
											Type:   "string",
											Format: "date-time",
										},
										"timePointer": {
											Type:     "string",
											Format:   "date-time",
											Nullable: true,
										},
									},
								},
								"status": {
									Type: "object",
									Required: []string{
										"conditions",
									},
									Properties: map[string]v1.JSONSchemaProps{
										"conditions": {
											Type: "array",
											Items: &v1.JSONSchemaPropsOrArray{
												Schema: &v1.JSONSchemaProps{
													Type: "object",
													Required: []string{
														"type",
														"status",
														"lastTransitionTime",
														"reason",
														"message",
													},
													Properties: map[string]v1.JSONSchemaProps{
														"lastTransitionTime": {
															Description: "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
															Type:        "string",
															Format:      "datetime",
														},
														"message": {
															Description: "message is a human readable message indicating details about the transition.\nThis may be an empty string.",
															Type:        "string",
															MaxLength:   ptr.To[int64](32768),
														},
														"observedGeneration": {
															Description: "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
															Type:        "integer",
															Format:      "int64",
															Minimum:     ptr.To[float64](0),
														},
														"reason": {
															Description: "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
															Type:        "string",
															MaxLength:   ptr.To[int64](1024),
															MinLength:   ptr.To[int64](1),
															Pattern:     `^[AZaZ]([AZaZ09,]*[AZaZ09])?$`,
														},
														"status": {
															Description: "status of the condition, one of True, False, Unknown.",
															Type:        "string",
															Enum: []v1.JSON{
																{
																	Raw: []byte(`"True"`),
																},
																{
																	Raw: []byte(`"False"`),
																},
																{
																	Raw: []byte(`"Unknown"`),
																},
															},
														},
														"type": {
															Description: "type of condition in CamelCase or in foo.example.com/CamelCase.\n---\nMany .condition.type values are consistent across resources like Available, but because arbitrary conditions can be\nuseful (see .node.status.conditions), the ability to deconflict is important.\nThe regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
															Type:        "string",
															MaxLength:   ptr.To[int64](316),
															Pattern:     `^([aZ09]([AZ09]*[aZ09])?(\.[aZ09]([AZ09]*[aZ09])?)*/)?(([AZaZ09][AZaZ09.]*)?[AZaZ09])$`,
														},
													},
												},
											},
											Nullable: true,
										},
									},
								},
							},
						},
					},
					Subresources: &v1.CustomResourceSubresources{
						Status: &v1.CustomResourceSubresourceStatus{},
					},
				},
			},
		},
	}
}
